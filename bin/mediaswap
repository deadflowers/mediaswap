#!/usr/bin/env bash
# =============================================================================
# mediaswap: Unified media tool (Image, Audio, Video, Iconset, ASCII)
# Version: 1.1.0
# Ray Kooyenga
# 11-24-2025
# =============================================================================
# Dependencies: ffmpeg, imagemagick, zenity, jp2a (opt), chafa (opt), exiftool (opt)

set -u

# --- Defaults ---
VERSION="1.1.0"
IMG_QUALITY=75
AUDIO_BITRATE_OPUS="256k"
AUDIO_BITRATE_STD="320k"
VIDEO_CRF_DEFAULT=32
VIDEO_PRESET_SPEED=2
USE_GPU="no"
OVERWRITE="no"
STRIP_META="no"

# --- Helpers ---

log() { printf "[%s] %s\n" "$(date +%H:%M:%S)" "$*" >&2; }
err() { printf "[ERR] %s\n" "$*" >&2; exit 1; }

# Check dependencies
for cmd in zenity convert file ffmpeg; do
    command -v "$cmd" >/dev/null 2>&1 || err "Missing dependency: $cmd"
done

# Safe output filename generator (avoids overwrite)
next_filename() {
    local file="$1"
    if [[ ! -e "$file" ]]; then echo "$file"; return; fi
    local dir filename ext i=1
    dir=$(dirname "$file")
    filename=$(basename -- "$file")
    ext="${filename##*.}"
    filename="${filename%.*}"
    while [[ -e "${dir}/${filename}_${i}.${ext}" ]]; do ((i++)); done
    echo "${dir}/${filename}_${i}.${ext}"
}

# Progress GUI Wrapper
run_progress() {
    local title="$1"; shift
    if [ ! -t 0 ]; then
        ("$@" 2>&1) | zenity --progress --pulsate --title="MediaSwap" --text="$title" --auto-close --no-cancel
    else
        echo "-> $title"
        "$@"
    fi
}

# --- 1. IMAGE MODULE ---
mode_image() {
    local action="${1:-}"
    shift
    local files=("$@")

    # GUI Menu
    if [[ -z "$action" || -f "$action" ]]; then
        [[ -f "$action" ]] && files=("$action" "${files[@]}")
        # Detect if multiple files are selected for "Create Animation" option
        local anim_opt=""
        if [ "${#files[@]}" -gt 1 ]; then anim_opt="TRUE \"animwebp\" \"Create Animated WebP (from selection)\""; fi
        
        action=$(zenity --list --title="Image Tools" --height=500 --width=450 \
            --column="Action" --column="Description" \
            "webp" "Convert to WebP" \
            "avif" "Convert to AVIF" \
            "png" "Convert to PNG" \
            "jpg" "Convert to JPG" \
            "animwebp" "Create Animated WebP (GIF style)" \
            "bevel" "Add transparent bevel" \
            "rappleshot" "Add shadow (Rappleshot)" \
            "bgremove" "Remove background (Select color)" \
            "iconset" "Generate Iconset folder" \
            "ascii" "Convert to ASCII (chafa)" \
            "strip" "Scrub Metadata (Same format)") || exit 0
        GUI_MODE="true"
    fi

    # Special Case: Animated WebP from multiple images (Combines inputs)
    if [[ "$action" == "animwebp" ]]; then
        local out_name
        if [ "${#files[@]}" -gt 0 ]; then
             local first_dir; first_dir=$(dirname "${files[0]}")
             out_name="${first_dir}/animation.webp"
        else
             out_name="animation.webp"
        fi
        out_name=$(next_filename "$out_name")
        
        # Delay 20 = 20/100 seconds (5 fps) - tweak as needed or ask user
        run_progress "Creating Animation..." convert -delay 20 -loop 0 "${files[@]}" "$out_name"
        return 0
    fi

    # Params for GUI or defaults
    local q_val="$IMG_QUALITY"
    case "$action" in
        webp|jpg|jpeg|avif)
            [ "${GUI_MODE:-false}" = "true" ] && q_val=$(zenity --scale --title="Quality" --value=75 --min-value=1 --max-value=100)
            ;;
    esac

    for f in "${files[@]}"; do
        [ ! -f "$f" ] && continue
        local dir base ext out
        dir=$(dirname "$f")
        base=$(basename "${f%.*}")
        ext="${f##*.}"
        
        case "$action" in
            webp)
                out=$(next_filename "${dir}/${base}.webp")
                run_progress "To WebP: $base" convert "$f" -quality "$q_val" "$out"
                ;;
            avif)
                out=$(next_filename "${dir}/${base}.avif")
                run_progress "To AVIF: $base" convert "$f" -quality "$q_val" "$out"
                ;;
            jpg|jpeg)
                out=$(next_filename "${dir}/${base}.jpg")
                run_progress "To JPG: $base" convert "$f" -quality "$q_val" -background white -flatten "$out"
                ;;
            png)
                out=$(next_filename "${dir}/${base}.png")
                run_progress "To PNG: $base" convert "$f" "$out"
                ;;
            bevel)
                out=$(next_filename "${dir}/${base}_bevel.png")
                run_progress "Beveling: $base" convert "$f" -alpha set -bordercolor none -border 16 -raise 16 "$out"
                ;;
            rappleshot)
                out=$(next_filename "${dir}/${base}_rapple.png")
                run_progress "Shadowing: $base" convert "$f" \( +clone -background black -shadow 80x20+0+15 \) +swap -background transparent -layers merge +repage "$out"
                ;;
            bgremove)
                local fuzz="15"
                [ "${GUI_MODE:-false}" = "true" ] && fuzz=$(zenity --scale --title="Aggressiveness" --value=15 --max-value=50)
                out=$(next_filename "${dir}/${base}_nobg.png")
                run_progress "Removing BG: $base" convert "$f" -alpha on -fuzz "${fuzz}%" -transparent white "$out"
                ;;
            iconset)
                local idir="${dir}/${base}_iconset"
                mkdir -p "$idir"
                run_progress "Generating Iconset: $base" bash -c "
                    convert \"$f\" -resize 16x16 \"$idir/16.png\"
                    convert \"$f\" -resize 32x32 \"$idir/32.png\"
                    convert \"$f\" -resize 48x48 \"$idir/48.png\"
                    convert \"$f\" -resize 128x128 \"$idir/128.png\"
                    convert \"$f\" -resize 256x256 \"$idir/256.png\"
                    convert \"$f\" -resize 512x512 \"$idir/512.png\"
                    convert \"$idir/16.png\" \"$idir/32.png\" \"$idir/48.png\" \"$idir/favicon.ico\"
                "
                ;;
            ascii)
                if command -v chafa >/dev/null; then
                   chafa "$f" > "${dir}/${base}.txt"
                elif command -v jp2a >/dev/null; then
                   jp2a "$f" > "${dir}/${base}.txt"
                fi
                ;;
            strip)
                out=$(next_filename "${dir}/${base}_clean.${ext}")
                if command -v exiftool >/dev/null; then
                    cp "$f" "$out" && exiftool -overwrite_original -all= "$out"
                else
                    convert "$f" -strip "$out"
                fi
                ;;
        esac
    done
}

# --- 2. AUDIO MODULE ---
mode_audio() {
    local action="${1:-}"
    shift
    local files=("$@")

    if [[ -z "$action" || -f "$action" ]]; then
        if [[ -f "$action" ]]; then files=("$action" "${files[@]}"); fi
        action=$(zenity --list --title="Audio Tools" --height=350 --width=400 \
            --column="Action" --column="Desc" \
            "opus" "To Opus (Default High Quality)" \
            "m4a" "To AAC/M4A (320k)" \
            "mp3" "To MP3 (320k)" \
            "flac" "To FLAC (Lossless)" \
            "wav" "To WAV (PCM 16-bit)" \
            "ogg" "To OGG (Vorbis)" \
            "norm" "Normalize voice recording for transcription" \
            "rip" "Rip Audio (Copy if possible)") || exit 0
        GUI_MODE="true"
    fi

    for f in "${files[@]}"; do
        [ ! -f "$f" ] && continue
        local dir base ext out
        dir=$(dirname "$f")
        base=$(basename "${f%.*}")
        
        case "$action" in
            opus)
                out=$(next_filename "${dir}/${base}.opus")
                run_progress "Encoding Opus..." ffmpeg -y -i "$f" -c:a libopus -b:a "$AUDIO_BITRATE_OPUS" -vn "$out"
                ;;
            m4a|aac)
                out=$(next_filename "${dir}/${base}.m4a")
                run_progress "Encoding AAC..." ffmpeg -y -i "$f" -c:a aac -b:a "$AUDIO_BITRATE_STD" -vn "$out"
                ;;
            mp3)
                out=$(next_filename "${dir}/${base}.mp3")
                run_progress "Encoding MP3..." ffmpeg -y -i "$f" -c:a libmp3lame -b:a "$AUDIO_BITRATE_STD" -vn "$out"
                ;;
            flac)
                out=$(next_filename "${dir}/${base}.flac")
                run_progress "Encoding FLAC..." ffmpeg -y -i "$f" -c:a flac -vn "$out"
                ;;
            wav|wave|pcm)
                out=$(next_filename "${dir}/${base}.wav")
                run_progress "Encoding WAV..." ffmpeg -y -i "$f" -c:a pcm_s16le -vn "$out"
                ;;
            ogg)
                out=$(next_filename "${dir}/${base}.ogg")
                run_progress "Encoding OGG..." ffmpeg -y -i "$f" -c:a libvorbis -q:a 6 -vn "$out"
                ;;
            voice|norm|normal)
                out=$(next_filename "${dir}/${base}_normal.wav")
                run_progress "Optimizing for transcription..." ffmpeg -y -i "$f" -af "highpass=f=100, dynaudnorm=f=150:g=31:p=0.9, volume=1.5" -ar 16000 -ac 1 -vn "$out"
                ;;
            rip)
                # Try copy first
                out=$(next_filename "${dir}/${base}.mka")
                if ! ffmpeg -y -i "$f" -c:a copy -vn "$out" >/dev/null 2>&1; then
                    # Fallback if copy fails
                    out=$(next_filename "${dir}/${base}.opus")
                    run_progress "Rip failed, transcoding..." ffmpeg -y -i "$f" -c:a libopus -b:a 192k -vn "$out"
                fi
                ;;
        esac
    done
}

# --- 3. VIDEO MODULE ---
mode_video() {
    local action="${1:-}"
    shift
    local files=("$@")

    if [[ -z "$action" || -f "$action" ]]; then
        if [[ -f "$action" ]]; then files=("$action" "${files[@]}"); fi
        action=$(zenity --list --title="Video Tools" --height=420 --width=400 \
            --column="Action" --column="Desc" \
            "vp8" "To WebM (VP8 - Compatible)" \
            "vp9" "To WebM (VP9 - Efficient)" \
            "av1" "To WebM (AV1 - Best/Slow)" \
            "h264" "To MP4 (H.264 - Common)" \
            "h265" "To MP4 (H.265 - Modern)" \
            "mov" "To MOV (ProRes/H264)" \
            "vid2webp" "To Animated WebP (High Quality)" \
            "lossless" "To Lossless (VP9)" \
            "rip" "Rip Audio Only") || exit 0
        GUI_MODE="true"
    fi

    # GPU Flag check
    local h264_codec="libx264"
    local h265_codec="libx265"
    
    if [[ "$USE_GPU" == "yes" ]]; then
        # Rudimentary Nvidia check
        if command -v nvidia-smi >/dev/null; then
             h264_codec="h264_nvenc"
             h265_codec="hevc_nvenc"
        fi
    fi

    for f in "${files[@]}"; do
        [ ! -f "$f" ] && continue
        local dir base out
        dir=$(dirname "$f")
        base=$(basename "${f%.*}")

        case "$action" in
            vp8|webm)
                out=$(next_filename "${dir}/${base}.webm")
                # Defaulting to VP8 for 'webm' generic request as user requested
                run_progress "VP8 Encoding..." ffmpeg -y -i "$f" -c:v libvpx -crf 10 -b:v 1M -c:a libvorbis "$out"
                ;;
            vp9)
                out=$(next_filename "${dir}/${base}.webm")
                run_progress "VP9 Encoding..." ffmpeg -y -i "$f" -c:v libvpx-vp9 -crf "$VIDEO_CRF_DEFAULT" -b:v 0 -c:a libopus "$out"
                ;;
            av1)
                out=$(next_filename "${dir}/${base}.webm")
                run_progress "AV1 Encoding..." ffmpeg -y -i "$f" -c:v libaom-av1 -crf 30 -b:v 0 -cpu-used 4 -c:a libopus "$out"
                ;;
            h264)
                out=$(next_filename "${dir}/${base}.mp4")
                run_progress "H264 Encoding..." ffmpeg -y -i "$f" -c:v "$h264_codec" -crf 23 -c:a copy "$out"
                ;;
            h265)
                out=$(next_filename "${dir}/${base}.mp4")
                run_progress "H265 Encoding..." ffmpeg -y -i "$f" -c:v "$h265_codec" -crf 28 -c:a copy "$out"
                ;;
            mov)
                out=$(next_filename "${dir}/${base}.mov")
                # Defaulting MOV to a high quality h264 for compatibility
                run_progress "MOV Encoding..." ffmpeg -y -i "$f" -c:v "$h264_codec" -q:v 0 -c:a copy "$out"
                ;;
            vid2webp)
                # Video to Animated WebP using flags from the HTML reference
                out=$(next_filename "${dir}/${base}.webp")
                # Note: -vsync 0 deprecated for -fps_mode passthrough
                run_progress "Animated WebP..." ffmpeg -y -i "$f" -vcodec libwebp -filter:v fps=20 -lossless 0 -compression_level 4 -q:v 75 -loop 0 -preset default -an -fps_mode passthrough -s 800:-1 "$out"
                ;;
            lossless)
                out=$(next_filename "${dir}/${base}_lossless.webm")
                run_progress "Lossless..." ffmpeg -y -i "$f" -c:v libvpx-vp9 -lossless 1 -c:a copy "$out"
                ;;
            rip)
                out=$(next_filename "${dir}/${base}.mka")
                ffmpeg -y -i "$f" -c:a copy -vn "$out"
                ;;
        esac
    done
}

# --- Help / Dispatcher ---

show_help() {
    cat <<EOF
mediaswap v$VERSION

Usage: m [i|a|v] [action] [files...]

IMAGES (i):
  m i webp         Convert to WebP
  m i avif         Convert to AVIF
  m i png          Convert to PNG
  m i jpg|jpeg     Convert to JPG
  m i animwebp     Create animated WebP from multiple input images
  m i bevel        Add transparent 3D bevel
  m i rappleshot   Add screenshot shadow
  m i bgremove     Remove background
  m i iconset      Generate standard icon sizes folder
  m i ascii        Convert to ASCII text file

AUDIO (a):
  m a opus         Convert to Opus
  m a m4a|aac      Convert to AAC/M4A
  m a mp3          Convert to MP3
  m a flac         Convert to FLAC
  m a wav|pcm      Convert to WAV
  m a ogg          Convert to OGG Vorbis
  m a rip          Extract audio stream from video (copy)

VIDEO (v):
  m v vp8|webm     Convert to WebM (VP8)
  m v vp9          Convert to WebM (VP9)
  m v av1          Convert to WebM (AV1)
  m v h264         Convert to MP4 (H.264)
  m v h265         Convert to MP4 (H.265)
  m v mov          Convert to MOV
  m v vid2webp     Convert video to Animated WebP (GIF style)
  m v lossless     Convert to lossless WebM

Global Flags:
  --gpu            Enable GPU encoding (NVENC) where supported
  --force          Allow overwriting files (Not implemented yet, currently appends _1)
EOF
}

# Handle global flags manually
ARGS=()
for arg in "$@"; do
    case "$arg" in
        --gpu) USE_GPU="yes" ;;
        --help|-h) show_help; exit 0 ;;
        *) ARGS+=("$arg") ;;
    esac
done
set -- "${ARGS[@]}"

MODE="${1:-}"
shift || true

case "$MODE" in
    i|img|image)
        mode_image "$@"
        ;;
    a|aud|audio)
        mode_audio "$@"
        ;;
    v|vid|video)
        mode_video "$@"
        ;;
    *)
        if [ -n "$MODE" ] && [ -f "$MODE" ]; then
            zenity --error --text="Please specify mode: image (i), audio (a), or video (v)."
        else
            show_help
        fi
        ;;
esac
